<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    .cell {
      width: 70px;
      height: 70px;
      background-color: #13ab13;
    }

    @media screen and (max-width:500px) {

      .cell {
        width: 10vw;
        height: 10vw;
      }

      #button_area {
        width: 60vw;
        height: 16vw;
        margin: auto;
      }

      #button_area>button {
        font-size: 5vw;
        padding: 2vw;
        font-weight: bold;
        border: none;
        font-family: monospace;
      }

      #button_area>button:hover {
        transform: scale(1.1);
      }

      #reset {
        background-color: black;
        color: white;
      }

      #hint {
        float: right;
        background-color: white;
        color: black;
      }

      #text>div {
        display: inline-block;
        width: 3vw;
        height: 3vw;
        border-radius: 50%;
        background-color: black;
      }

      #canvas1 {
        width: 32vw;
        display: block;
        margin: auto;
        padding: 10px;
        border: 1vw solid black;
        border-top: 1vw solid white;
        border-left: white solid 1vw;
      }

      #result_canvas {
        width: 100%;
        position: absolute;
        top: 36vw;
        transition: transform 1.2s;
        transition-timing-function: linear;
      }

    }

    html,
    body {
      overflow: hidden
    }

    html {
      width: 100%;
      height: 100%;
    }

    body {
      position: absolute;
      width: 100%;
      height: 100%;
      margin: 0;
      background: linear-gradient(0deg, rgba(0, 0, 0, 1) 0%, rgba(255, 255, 255, 1) 100%);
      background: lightgray;
    }

    table {
      background-color: black;
      margin: 5vw auto;
    }

    td>div {
      width: 90%;
      height: 90%;
      margin: auto;
      border-radius: 50%;
    }

    .black {
      background-color: black;
    }

    .white {
      background-color: white;
    }

    .hint {
      display: inline-block;
      width: 100%;
      font-size: 5vw;
      text-align: center;
    }

    [data-plus="t"] {
      color: yellow;
    }

    [data-plus="f"] {
      color: #2222ff;
    }
  </style>
  <style id="none">
    div:not(#body),
    canvas {
      display: none;
    }
  </style>
  <title>詰めオセロ</title>
</head>

<body>

  <div id="body">
    <button onclick="start()" id="start">sssssssss</button>
  </div>
  <div id="button_area">
    <button id="reset">リセット</button>
    <button id="hint">ヒント</button>
  </div>
  <canvas id="canvas1" width="157" height="45"></canvas>
  <div id="result"></div>
  <canvas id="result_canvas" width="500" height="150" style="display: none; transform: scale(0);"></canvas>

  <script>

    function start() {
      document.getElementById('body').innerHTML = '作成中';
      console.log(document.getElementById('body').innerHTML, Date.now())
      setTimeout(all, 10);
    }

    //function all(){
    const way = [[-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1]];
    let DATA, copyDATA;
    let kif = 'f5';
    let player = true;//プレイヤーのターン
    let player_color
    let vacant = [];//空きマス

    function check(p, c, d) {//pに置けるか c=色 d=DATA
      let p0 = Number(p[0]);
      let p1 = Number(p[1]);
      let o = c % 2 + 1;
      let tonari = [];
      for (let i = 0; i < 8; i++) {//隣に相手の石があるか
        let w0 = way[i][0];
        let w1 = way[i][1];
        tonari.push(d[p0 + w0][p1 + w1] == o);
      }

      for (let i = 0; i < 8; i++) {
        if (!tonari[i]) continue;//隣に相手の石があったところだけチェック
        let w0 = way[i][0];
        let w1 = way[i][1];
        for (let j = 2; true; j++) {
          if (d[p0 + w0 * j][p1 + w1 * j] == 0 || d[p0 + w0 * j][p1 + w1 * j] == 3) break;
          if (d[p0 + w0 * j][p1 + w1 * j] == c) { return true; }
        }
      }
      return false;
    }

    const abc = [0, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
    function put(p, c, d, display, ki) {
      let p0 = Number(p[0]);
      let p1 = Number(p[1]);
      let o = c % 2 + 1;

      d[p0][p1] = c;
      if (display) document.getElementById('c' + p).innerHTML = `<div class="${[0, 'black', 'white'][c]}" id=k${p}>`;
      if (ki) kif += abc[p[1]] + p[0];

      let tonari = [];
      for (let i = 0; i < 8; i++) {//隣に相手の石があるか
        let w0 = way[i][0];
        let w1 = way[i][1];
        tonari.push(d[p0 + w0][p1 + w1] == o);
      }

      for (let i = 0; i < 8; i++) {
        if (!tonari[i]) continue;//隣に相手の石があったところだけチェック
        let w0 = way[i][0];
        let w1 = way[i][1];
        let list = [[p0 + w0, p1 + w1]];//返す石リスト
        for (let j = 2; true; j++) {
          if (d[p0 + w0 * j][p1 + w1 * j] == 0 || d[p0 + w0 * j][p1 + w1 * j] == 3) break;
          if (d[p0 + w0 * j][p1 + w1 * j] == o) {
            list.push([p0 + w0 * j, p1 + w1 * j]);
          } else {
            for (let i2 = 0; i2 < list.length; i2++) {//リスト内の石を返す
              let l = list[i2];
              d[l[0]][l[1]] = c;
              if (display) document.getElementById('k' + l[0] + l[1]).className = [0, 'black', 'white'][c];
            }
            break;
          }
        }
      }
    }

    function valuation(d, p, c, h, Z) {//評価値計算 (データ,残りマス,色,評価の視点)
      //console.group();
      //console.log(c, '視点      置く候補', p); hyouji(d);
      let o = c % 2 + 1;//相手
      let can = [];//c が置ける場所があるか
      for (let i = 0; i < p.length; i++) {
        if (check(p[i], c, d)) can.push(p[i]);
      }
      if (!can.length) {//どこにも置けなかったら
        for (let i = 0; i < p.length; i++) {
          if (check(p[i], o, d)) can.push(p[i]);
        }
        if (!can.length) {//相手も置けなければ石を数えて終了
          //console.groupEnd();
          let cc = count_color(d);
          let point = cc[h] - cc[h % 2 + 1];
          if (cc[0]) {//空きマスがあったら勝っているほうにカウント
            if (point > 0) {
              point += cc[0];
            } else if (point < 0) {
              point -= cc[0];
            }
          }
          return point;
        } else {//相手は置けるなら自分pass
          //console.groupEnd();
          return valuation(d, p, o, h);
        }
      }

      let point = [];
      for (let i = 0; i < can.length; i++) {//置ける全てのマスの評価値を計算
        let karid = copy(d);//仮のデータ
        put(can[i], c, karid);
        let karip = p.concat();
        karip.splice(karip.indexOf(can[i]), 1);
        point.push(valuation(karid, karip, o, h));
      }
      //console.groupEnd();
      return Z ? point : c == h ? Math.max(...point) : Math.min(...point);
    }

    function adjustment(d, p, c, t, count) {////最大評価値が+2の問題にする(データ、残りマス、置けるところ,ターン)
      let point = valuation(d, p, t, t, true);//評価値計算
      if (point.indexOf(-2) > -1) {//置いたら-2(相手視点で+2になる)
        put(c[point.indexOf(-2)], t, d, false, true);
        console.log(t + 'が', c[point.indexOf(-2)], 'において完成')
        return t % 2 + 1;
      }
      if (Math.max(...point) == 2) {//最善が+2
        console.log('このままでOK')
        return t;
      }
      if (point.indexOf(2) > -1) {//+2置いて-2置けば完成
        put(c[point.indexOf(2)], t, d, false, true);//+2に置く
        p.splice(p.indexOf(c[point.indexOf(2)]), 1);
        let o = t % 2 + 1;
        c = canlist(d, p, o);
        if (!c.length) return false;
        point = valuation(d, p, o, o, true);
        put(c[point.indexOf(-2)], o, d, false, true);//-2に置く
        console.log('+2  -2 で完成')
        return t;
      }

      let k = t;//仮のターン
      d = copy(d);
      for (let k = t; true; k = k % 2 + 1) {//勝つ手筋が1つだけなら完成
        let pass = false;
        do {//相手がパスなら繰り返し
          let m = Math.max(...point);
          if (k == t) {//プレイヤーのターンに勝ち筋が
            if (m < 1) return false;//1つも無ければだめ
            let sec = second(point);
            if (sec > 0) return false;//2つ以上あってもだめ
          }
          put(c[point.indexOf(m)], k, d, false, false);//互いに最善
          p.splice(p.indexOf(c[point.indexOf(m)]), 1);
          c = canlist(d, p, k % 2 + 1);//相手の置けるところ
          if (c.length) {
            point = valuation(d, p, k % 2 + 1, k % 2 + 1, true);
          } else {//相手パス
            c = canlist(d, p, k);//自分の置けるところ
            if (!c.length) return 2 + t;//falseにならずに終われば成功
            pass = true;
            point = valuation(d, p, k, k, true);
          }
        } while (pass)//相手パスなら
      }




      return false;
    }

    function create(NUM) {//問題作成
      console.log('作成開始')
      DATA = [];/////let DATA
      kif = 'f5';
      for (let i = 0; i < 10; i++) {
        DATA.push([]);
        for (let j = 0; j < 10; j++) {
          DATA[i].push(i == 0 || i == 9 || j == 0 || j == 9 ? 3 : 0);
        }
      }
      DATA[4][4] = 2;
      DATA[4][5] = 1;
      DATA[5][4] = 1;
      DATA[5][5] = 1;
      DATA[5][6] = 1;

      let put_position = ['33', '34', '35', '36', '46', '47', '57', '67', '66', '65', '64', '63', '53', '43'];//置けそうな場所

      for (let t = 1; t < NUM; t++) {//NUM 手ランダムに置いて問題盤面を作る
        let c = t % 2 + 1;
        let can = [];
        for (let i = 0; i < put_position.length; i++) {
          if (check(put_position[i], c, DATA)) can.push(put_position[i]);
        }
        if (!can.length) {
          console.log('やり直し');
          return false;//パスになったらやり直し
        }
        can = can[Math.floor(Math.random() * can.length)];//置けるところからランダム
        put(can, c, DATA, false, true);
        put_position.splice(put_position.indexOf(can), 1);
        for (let i = 0; i < 8; i++) {
          let w0 = way[i][0];
          let w1 = way[i][1];
          let pu = Number(can[0]) + w0 + '' + +(Number(can[1]) + w1);
          if (DATA[pu[0]][pu[1]] == 0 && put_position.indexOf(pu) == -1) put_position.push(pu);
        }
      }

      put_position = [];//残りは数マスなので全て入れる
      for (let i = 1; i < 9; i++) {
        let k = DATA[i].concat();
        let ki = k.indexOf(0);
        while (ki > -1) {
          k[ki] = 4;
          put_position.push('' + i + ki);
          ki = k.indexOf(0);
        }
      }

      let t = NUM % 2 + 1;//tのターン
      let can = [];//tの置ける場所
      for (let i = 0; i < put_position.length; i++) {
        if (check(put_position[i], t, DATA)) can.push(put_position[i]);
      }
      if (can.length < 2) {//置けるところが少ない場合やり直し
        return false;
      }

      if (put_position.length > 10) {
        return false;
      }
      let s = adjustment(DATA, put_position, can, t, 0);//数を調整
      //let s = 3;
      if (!s) return false;
      let count = count_color(DATA);
      if (s < 3) {//通常
        if (count[s] > count[s % 2 + 1]) return false;
      } else {//勝ち筋1つの問題
        s -= 2;
        console.log('%c1つ', 'color:red')
      }

      console.log(count, '今の数')
      return s;
    }

    function touch(p) {
      if (!player || !check(p, player_color, DATA)) return;
      let hint = document.getElementsByClassName('hint');
      while (hint.length) {
        hint[0].remove();
      }
      player = false;
      put(p, player_color, DATA, true);
      vacant.splice(vacant.indexOf(p), 1);
      if (!vacant.length) {//空きマスがなくなった
        end();
        return;
      }
      let can = canlist(DATA, vacant, player_color % 2 + 1);
      if (!can.length) {//COMパス
        if (canlist(DATA, vacant, player_color).length) {//プレイヤーは置ける
          player = true;
          return;
        } else {//プレイヤーも置けない
          end();
          return;
        }
      }
      setTimeout(() => {
        com(can);//COM思考
      }, 700);

    }

    function com(can) {
      let o = player_color % 2 + 1;
      let hyouka = valuation(DATA, vacant, o, o, true);
      let max = Math.max(...hyouka);
      let mass = can[hyouka.indexOf(max)];
      put(mass, o, DATA, true);
      vacant.splice(vacant.indexOf(mass), 1);
      if (!vacant.length) {//空きマスがなくなった
        end();
        return;
      }
      if (canlist(DATA, vacant, player_color).length) {
        player = true;
      } else {//プレイヤーがパスならもう一度COM
        can.splice(can.indexOf(mass), 1);
        setTimeout(() => {
          com(can);
        }, 700);
      }
    }

    const result = document.getElementById('result');
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function end() {
      let count = count_color(DATA);
      result.innerText = `黒${count[1]}  白${count[2]}
        ${count[player_color] > count[player_color % 2 + 1] ? '勝利!' : ''}`;
      const result_canvas = document.getElementById('result_canvas');
      const ctx2 = result_canvas.getContext('2d');
      ctx2.beginPath();
      if (count[player_color] > count[player_color % 2 + 1]) {
        ctx2.fillStyle = 'red';
        ctx2.textBaseline = "hanging";
        ctx2.font = '150px fantasy';
        ctx2.fillText('WIN', (500 - ctx2.measureText("WIN").width) / 2, 0);
        ctx2.strokeStyle = 'yellow';
        ctx2.strokeText('WIN', (500 - ctx2.measureText("WIN").width) / 2, 0);
        result_canvas.style.display = '';
        setTimeout(() => {
          result_canvas.style.transform = 'scaleX(1.3)';
        }, 10);
      }

    }

    function hint() {
      if (!player) return;
      let point = valuation(DATA, vacant, player_color, player_color, true);
      let can = canlist(DATA, vacant, player_color);
      for (let i = 0; i < can.length; i++) {
        let po = point[i];
        document.getElementById('c' + can[i]).innerHTML = `<span id=h${can[i]} class='hint' data-plus="${po > 0 ? 't' : 'f'}">${po > 0 ? '+' : ''}${po}</span>`;
      }

    }

    function reset() {
      DATA = copy(copyDATA);
      vacant = [];
      for (let i = 1; i < 9; i++) {
        for (let j = 1; j < 9; j++) {
          if (DATA[i][j]) {
            document.getElementById('c' + i + j).innerHTML = `<div class="${[0, 'black', 'white'][DATA[i][j]]}" id="k${i}${j}"></div>`;
          } else {
            document.getElementById('c' + i + j).innerHTML = '';
            vacant.push('' + i + j);
          }
        }
      }
      player = true;
      result.innerText = '';
    }

    function copy(d) {//2次元配列をコピー
      let c = [];
      for (let i = 0; i < d.length; i++) {
        c.push(d[i].concat());
      }
      return c;
    }

    function abs(a) {//絶対値
      let b = [];
      for (let i = 0; i < a.length; i++) {
        b.push(Math.abs(a[i]));
      }
      return b;
    }

    function canlist(d, p, c) {//置けるところ
      let can = [];
      for (let i = 0; i < p.length; i++) {
        if (check(p[i], c, d)) can.push(p[i]);
      }
      return can;
    }

    function count_color(d) {//白黒　石の数
      let count = [0, 0, 0];
      for (let i = 1; i < 9; i++) {
        for (let j = 1; j < 9; j++) {
          count[d[i][j]]++;
        }
      }
      return count;
    }

    function second(a) {//配列中の2番目に大きい数
      a = a.concat();
      let m = Math.max(...a);
      a[a.indexOf(m)] = -100;
      return Math.max(...a);
    }

    const nanido = 53;//50限界
    do {
      player_color = create(nanido + Math.floor(Math.random() * 2));
    } while (!player_color)
    copyDATA = copy(DATA);

    let body = document.getElementById('body');
    body.innerHTML = '';
    let table = document.createElement('table');//盤面作成
    for (let i = 1; i < 9; i++) {
      let tr = document.createElement('tr');
      for (let j = 1; j < 9; j++) {
        let td = document.createElement('td');
        td.classList = 'cell';
        td.id = `c${i}${j}`;
        if (DATA[i][j]) {
          td.innerHTML = `<div class="${[0, 'black', 'white'][DATA[i][j]]}" id="k${i}${j}"></div>`;
        } else {
          vacant.push('' + i + j);
          td.onclick = (e) => {
            let id = e.target.id;
            id = id[1] + id[2];
            if (vacant.indexOf(id) > -1) touch(id);//空きマスにしか置けない
          }
        }

        tr.appendChild(td);
      }
      table.appendChild(tr);
    }
    body.appendChild(table);

    // let input = document.createElement('input');//棋譜エリア
    // input.type = 'text';
    // input.id = 'kif';
    // input.value = kif;
    // body.appendChild(input);
    // input = document.createElement('button');
    // input.id = 'copy';
    // input.innerText = 'コピー';
    // input.onclick = () => {
    //   document.getElementById('kif').select();
    //   document.execCommand("Copy");
    // }
    // body.appendChild(input);

    document.getElementById('reset').onclick = reset;

    document.getElementById('hint').onclick = hint;

    const canvas1 = document.getElementById('canvas1');
    canvas1.style.backgroundColor = [0, '#e8e8e8', '#cccccc'][player_color];
    const ctx1 = canvas1.getContext("2d");
    ctx1.beginPath();
    ctx1.fillStyle = [0, 'black', 'white'][player_color];
    ctx1.arc(20, 23, 20, 0, 2 * Math.PI, false);
    ctx1.fill();
    ctx1.font = '40px serif';
    ctx1.fillText('で勝て', 40, 40);

    document.getElementById('none').remove();


    //}all


    function hyouji(d) {
      if (!d) d = DATA;
      let m = [' ', '●', '○', ' '];
      let h = '';
      for (let i = 1; i < 9; i++) {
        for (let j = 1; j < 9; j++) {
          h += m[d[i][j]] + ' ';
        }
        h += '\n';
      }
      console.log(h)
    }

    //end()
  </script>
</body>

</html>
